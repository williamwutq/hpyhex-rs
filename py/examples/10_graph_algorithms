"""
Example 10: Various graph algorithms on HexEngine boards.
"""

import numpy as np
from hpyhex import HexEngine
from typing import List

def find_isolated_islands(engine: HexEngine) -> List[List[int]]:
    """
    Find all isolated islands (connected components) of unoccupied cells
    
    Uses depth-first search on the adjacency graph to identify connected
    components of unoccupied cells.
    
    Args:
        engine: The HexEngine to analyze
        
    Returns:
        List of lists, where each inner list contains the indices of cells
        in a connected component of unoccupied cells. Occupied cells are ignored.
        It is not possible to return an empty list, as at least one component
        (there will be space in the board due to eliminations) must exist.
    """
    # Get occupancy state and adjacency list
    occupied = engine.to_numpy_bool()
    adj_list = engine.to_numpy_adjacency_list_int32()  # int32 uses -1 as sentinel
    
    n = len(occupied)
    visited = np.zeros(n, dtype=bool)
    islands = []
    
    # Iterative DFS to find connected components
    def dfs(start: int) -> List[int]:
        stack = [start]
        visited[start] = True
        component = []
        
        while stack:
            cell = stack.pop()
            component.append(cell)
            
            # Check all 6 possible neighbors
            for i in range(6):
                neighbor = adj_list[cell, i]
                # Check if neighbor exists, is not occupied, and not visited
                if neighbor != -1 and not occupied[neighbor] and not visited[neighbor]:
                    visited[neighbor] = True
                    stack.append(neighbor)
        
        return component
    
    # Find all connected components of unoccupied cells
    for i in range(n):
        if occupied[i] and not visited[i]:
            islands.append(dfs(i))
    
    return islands


def detect_strategic_anomalies(engine: HexEngine, min_size: int = 4) -> List[List[int]]:
    """
    Detect strategic anomalies: isolated regions with fewer than min_size cells.
    
    Small isolated regions are problematic because they cannot accommodate
    most game pieces (which typically require 4+ connected cells). These
    regions represent "dead space" that reduces board efficiency.
    
    Args:
        engine: The HexEngine to analyze
        min_size: Minimum size threshold for viable regions (default: 4)
        
    Returns:
        List of lists, where each inner list contains the indices of cells
        in an anomalous region (size < min_size). Returns empty list if no
        anomalies are detected.
    """
    islands = find_isolated_islands(engine)
    return [island for island in islands if len(island) < min_size]


def count_islands(engine: HexEngine) -> int:
    """
    Count the number of isolated islands of unoccupied cells without storing all details.
    Fast metric for evaluating board fragmentation.
    
    Args:
        engine: The HexEngine to analyze
        
    Returns:
        Number of disconnected occupied regions.
    """
    return len(find_isolated_islands(engine))