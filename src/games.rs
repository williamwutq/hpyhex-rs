#![allow(dead_code)]
//! # Extended game extension to be able to read and intepret .hpyhex binary files, and to provide additional game management features.
//!
//! All bytes are in big-endian format. The binary file format is designed to be compact and efficient for storing game states, with a
//! header for validation and versioning, followed by a data section containing the grid state and metadata.

use crate::hex::{Hex, HexEngine, Piece};
use crate::meta::{ExtendedHexEngine, ExtendedGame};

// The following section are pulled from the java version. Don't question the constants.
// source: ./src/hexio/HexLogger.java
/// The version of this encoder compatible with .hpyhex binary format
const VERSION: &str = "0.1.0";
/// The version bytes for the current encoder, parsed from the VERSION string
const VERSION_BYTES: [u8; 4] = parse_version(VERSION).to_be_bytes();
/// Magic header for .hpyhex binary files, used to identify and validate the file format
const HEADER_MAGIC: [u8; 16] = 0x4B874B1E5A0F5A0F5A964B874B5A5A87u128.to_be_bytes();
/// Magic header for the data section of .hpyhex binary files, used to identify the start of the data block
const DATA_MAGIC: [u8; 8]    = str_to_bytes("!HEX-BIN");
/// Magic header indicate that these binary files are generated by this Rust encoder
/// 
/// The java version uses "JAVAHXLG"
const VERSION_MAGIC: [u8; 8] = str_to_bytes("hpyhexRS");
/// Bit shift values used for the hashing obfuscation process
const OBFUSC_SHIFTS: [u8; 8] = [31, 37, 41, 27, 23, 29, 33, 43];
/// A large prime number used in the hash function for mixing bits
/// 
/// It is noticible that this is not a prime number, but it is used in the java version,
/// so we will keep it for consistency. For simple obfuscation purposes, it is sufficient
/// to use this large odd number which has its factors in thousands.
/// 
/// `14514072000185962301` = `7561 * 1919596878744341`
const OBFUSC_PRIMT:  u64     = 0xC96C5795D7870F3Du64;

/// Obfuscates a long integer using bit shifts and prime multiplications.
/// This function provides a layered transformation for security purposes.
/// 
/// This is used for validating the integrity of the binary file and preventing tampering,
/// as well as for generating unique identifiers for game states.
/// 
/// ## Parameters
/// - `input`: The 64-bit unsigned integer to obfuscate.
/// 
/// ## Returns
/// A new 64-bit unsigned integer that is the obfuscated version of the input.
pub const fn obfuscate(mut input: u64) -> u64 {
    input ^= (input << OBFUSC_SHIFTS[0]) | (input >> OBFUSC_SHIFTS[1]);
    input = input.wrapping_mul(OBFUSC_PRIMT);
    input ^= (input << OBFUSC_SHIFTS[2]) | (input >> OBFUSC_SHIFTS[3]);
    input = input.wrapping_mul(OBFUSC_PRIMT);
    input ^= (input << OBFUSC_SHIFTS[4]) | (input >> OBFUSC_SHIFTS[5]);
    input = input.wrapping_mul(OBFUSC_PRIMT);
    input ^= (input << OBFUSC_SHIFTS[6]) | (input >> OBFUSC_SHIFTS[7]);
    input
}

/// Interleaves the bits of two 32-bit integers into a single 64-bit long.
/// It is superior to just combining two integers together.
///
/// The first integer contributes its bits to the even-numbered bit positions
/// (0, 2, 4, ...) of the result, while the second integer contributes its bits
/// to the odd-numbered bit positions (1, 3, 5, ...).
/// 
/// ## Inputs
/// - `even`: The 32-bit unsigned integer whose bits will occupy the even positions in the output.
/// - `odd`: The 32-bit unsigned integer whose bits will occupy the odd positions in the output.
/// 
/// ## Output
/// A 64-bit unsigned integer where the bits of `even` and `odd` are interleaved.
/// For example, if `even` is `0b1010` and `odd` is `0b0101`, the output will be `0b10011001`.
pub const fn interleave_integers(even: u32, odd: u32) -> u64 {
    let mut e_l = even as u64;
    let mut o_l = odd as u64;

    e_l = (e_l | (e_l << 16)) & 0x0000_FFFF_0000_FFFF;
    o_l = (o_l | (o_l << 16)) & 0x0000_FFFF_0000_FFFF;

    e_l = (e_l | (e_l << 8)) & 0x00FF_00FF_00FF_00FF;
    o_l = (o_l | (o_l << 8)) & 0x00FF_00FF_00FF_00FF;

    e_l = (e_l | (e_l << 4)) & 0x0F0F_0F0F_0F0F_0F0F;
    o_l = (o_l | (o_l << 4)) & 0x0F0F_0F0F_0F0F_0F0F;

    e_l = (e_l | (e_l << 2)) & 0x3333_3333_3333_3333;
    o_l = (o_l | (o_l << 2)) & 0x3333_3333_3333_3333;

    e_l = (e_l | (e_l << 1)) & 0x5555_5555_5555_5555;
    o_l = (o_l | (o_l << 1)) & 0x5555_5555_5555_5555;

    e_l ^ (o_l << 1)
}

/// Converts a string to a fixed-size byte array, padding with zeros if necessary.
/// 
/// ## Parameters
/// - `s`: The input string to convert.
/// - `N`: The size of the output byte array.
/// 
/// ## Returns
/// A byte array of size `N` containing the bytes of the input string,
/// padded with zeros if the string is shorter than `N`.
const fn str_to_bytes<const N: usize>(s: &str) -> [u8; N] {
    let bytes = s.as_bytes();
    let mut arr = [0u8; N];
    let mut i = 0;
    while i < bytes.len() && i < N {
        arr[i] = bytes[i];
        i += 1;
    }
    arr
}

/// Packs a semantic version (major.minor.patch) into a u32
/// Format: [major][minor][patch][0xFF] (big endian)
const fn version_bytes(major: u8, minor: u8, patch: u8) -> u32 {
    ((major as u32) << 24)
        | ((minor as u32) << 16)
        | ((patch as u32) << 8)
        | 0xFF
}

/// Parses a version string in the format "major.minor.patch" into a u32 using `version_bytes`.
const fn parse_version(s: &str) -> u32 {
    let bytes = s.as_bytes();
    let mut i = 0;

    let mut parts = [0u8; 3];
    let mut part = 0u8;
    let mut part_idx = 0;

    while i < bytes.len() {
        let b = bytes[i];
        if b == b'.' {
            parts[part_idx] = part;
            part_idx += 1;
            part = 0;
        } else {
            part = part * 10 + (b - b'0');
        }
        i += 1;
    }
    parts[part_idx] = part;

    version_bytes(parts[0], parts[1], parts[2])
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[repr(C)]
struct NibbleWriter {
    buffer: Vec<u8>,
    current_byte: u8,
    is_high_nibble: bool,
}

impl NibbleWriter {
    /// Creates a new NibbleWriter with an empty buffer and ready to write the high nibble of the first byte.
    /// 
    /// ## Returns
    /// A new instance of `NibbleWriter` ready for writing nibbles to its internal buffer.
    pub(crate) fn new() -> Self {
        Self {
            buffer: Vec::new(),
            current_byte: 0,
            is_high_nibble: true,
        }
    }

    /// Writes a single 4-bit nibble to the buffer, managing the current byte and nibble position.
    /// The nibble is masked to ensure only the lower 4 bits are used.
    /// 
    /// ## Parameters
    /// - `nibble`: The 8-bit unsigned integer containing the nibble to write (only the lower 4 bits are used).
    pub(crate) fn write_nibble(&mut self, nibble: u8) {
        let nibble = nibble & 0x0F; // Ensure it's only 4 bits
        if self.is_high_nibble {
            self.current_byte = nibble << 4; // Place in high nibble
        } else {
            self.current_byte |= nibble; // Place in low nibble
            self.buffer.push(self.current_byte); // Write full byte to buffer
            self.current_byte = 0; // Reset current byte
        }
        self.is_high_nibble = !self.is_high_nibble; // Toggle nibble position
    }

    /// Writes a full byte (8 bits) to the buffer by splitting it into two nibbles.
    /// The byte is written in big-endian order, with the high nibble written first, followed by the low nibble.
    /// 
    /// ## Parameters
    /// - `byte`: The 8-bit unsigned integer to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_u8(&mut self, byte: u8) {
        self.write_nibble(byte >> 4); // Write high nibble
        self.write_nibble(byte & 0x0F); // Write low nibble
    }

    /// Writes a 16-bit unsigned integer to the buffer by splitting it into two bytes and writing each byte as nibbles.
    /// The integer is written in big-endian order, with the high byte written first, followed by the low byte.
    /// 
    /// ## Parameters
    /// - `value`: The 16-bit unsigned integer to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_u16(&mut self, value: u16) {
        self.write_u8((value >> 8) as u8); // Write high byte
        self.write_u8(value as u8); // Write low byte
    }

    /// Writes a 32-bit unsigned integer to the buffer by splitting it into four bytes and writing each byte as nibbles.
    /// The integer is written in big-endian order, with the most significant byte written first, followed by the less significant bytes.
    /// 
    /// ## Parameters
    /// - `value`: The 32-bit unsigned integer to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_u32(&mut self, value: u32) {
        self.write_u16((value >> 16) as u16); // Write high word
        self.write_u16(value as u16); // Write low word
    }

    /// Writes a 64-bit unsigned integer to the buffer by splitting it into eight bytes and writing each byte as nibbles.
    /// The integer is written in big-endian order, with the most significant byte written first, followed by the less significant bytes.
    /// 
    /// ## Parameters
    /// - `value`: The 64-bit unsigned integer to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_u64(&mut self, value: u64) {
        self.write_u32((value >> 32) as u32);
        self.write_u32(value as u32);
    }

    /// Writes a slice of bytes to the buffer by writing each byte as nibbles.
    /// The bytes are written in the order they appear in the slice, with each byte split into high and low nibbles.
    /// 
    /// ## Parameters
    /// - `bytes`: A slice of bytes to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_bytes(&mut self, bytes: &[u8]) {
        for &byte in bytes {
            self.write_u8(byte);
        }
    }

    /// Writes a boolean value to the buffer as a single nibble, where `true` is represented as `1` and `false` is represented as `0`.
    /// This allows for compact storage of boolean values in the binary format.
    /// 
    /// ## Parameters
    /// - `value`: The boolean value to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_bool(&mut self, value: bool) {
        self.write_nibble(if value { 1 } else { 0 });
    }

    /// Writes a divider to the buffer by writing a specific nibble value (0xF) multiple times.
    /// This is used to separate different sections of the binary data for easier parsing and validation.
    /// 
    /// ## Parameters
    /// - `length`: The number of divider nibbles to write to the buffer.
    #[inline(always)]
    pub(crate) fn write_divider(&mut self, length: usize) {
        for _ in 0..length {
            self.write_nibble(0xF); // Use 0xF as a divider nibble
        }
    }

    /// Finalizes the buffer by flushing any remaining high nibble if necessary and returns the complete byte vector.
    /// If the last nibble written was a high nibble, it will be flushed to the buffer as a full byte before returning.
    /// 
    /// ## Returns
    /// A `Vec<u8>` containing the complete byte data that has been written to the buffer, ready for output or storage.
    pub(crate) fn into_bytes(mut self) -> Vec<u8> {
        if !self.is_high_nibble {
            self.buffer.push(self.current_byte); // Flush remaining high nibble if needed
        }
        self.buffer
    }
}

impl Into<Vec<u8>> for NibbleWriter {
    fn into(self) -> Vec<u8> {
        self.into_bytes()
    }
}
