#![allow(dead_code)]
//! # Extended game extension to be able to read and intepret .hpyhex binary files, and to provide additional game management features.
//!
//! All bytes are in big-endian format. The binary file format is designed to be compact and efficient for storing game states, with a
//! header for validation and versioning, followed by a data section containing the grid state and metadata.

use crate::hex::{Hex, HexEngine, Piece};
use crate::meta::{ExtendedHexEngine, ExtendedGame};

/// The version of this encoder compatible with .hpyhex binary format
const VERSION: &str = "0.1.0";
/// The version bytes for the current encoder, parsed from the VERSION string
const VERSION_BYTES: [u8; 4] = parse_version(VERSION).to_be_bytes();
/// Magic header for .hpyhex binary files, used to identify and validate the file format
const HEADER_MAGIC: [u8; 16] = 0x4B874B1E5A0F5A0F5A964B874B5A5A87u128.to_be_bytes();
/// Magic header for the data section of .hpyhex binary files, used to identify the start of the data block
const DATA_MAGIC: [u8; 8]    = str_to_bytes("!HEX-BIN");
/// Magic header indicate that these binary files are generated by this Rust encoder
/// 
/// The java version uses "JAVAHXLG"
const VERSION_MAGIC: [u8; 8] = str_to_bytes("hpyhexRS");

/// Converts a string to a fixed-size byte array, padding with zeros if necessary.
/// 
/// ## Parameters
/// - `s`: The input string to convert.
/// - `N`: The size of the output byte array.
/// 
/// ## Returns
/// A byte array of size `N` containing the bytes of the input string,
/// padded with zeros if the string is shorter than `N`.
const fn str_to_bytes<const N: usize>(s: &str) -> [u8; N] {
    let bytes = s.as_bytes();
    let mut arr = [0u8; N];
    let mut i = 0;
    while i < bytes.len() && i < N {
        arr[i] = bytes[i];
        i += 1;
    }
    arr
}

/// Packs a semantic version (major.minor.patch) into a u32
/// Format: [major][minor][patch][0xFF] (big endian)
const fn version_bytes(major: u8, minor: u8, patch: u8) -> u32 {
    ((major as u32) << 24)
        | ((minor as u32) << 16)
        | ((patch as u32) << 8)
        | 0xFF
}

/// Parses a version string in the format "major.minor.patch" into a u32 using `version_bytes`.
const fn parse_version(s: &str) -> u32 {
    let bytes = s.as_bytes();
    let mut i = 0;

    let mut parts = [0u8; 3];
    let mut part = 0u8;
    let mut part_idx = 0;

    while i < bytes.len() {
        let b = bytes[i];
        if b == b'.' {
            parts[part_idx] = part;
            part_idx += 1;
            part = 0;
        } else {
            part = part * 10 + (b - b'0');
        }
        i += 1;
    }
    parts[part_idx] = part;

    version_bytes(parts[0], parts[1], parts[2])
}