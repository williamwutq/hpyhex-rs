#![allow(dead_code)]
//! # Extended game extension to be able to read and intepret .hpyhex binary files, and to provide additional game management features.
//!
//! All bytes are in big-endian format. The binary file format is designed to be compact and efficient for storing game states, with a
//! header for validation and versioning, followed by a data section containing the grid state and metadata.

use crate::hex::{Hex, HexEngine, Piece};
use crate::meta::{ExtendedHexEngine, ExtendedGame};

// The following section are pulled from the java version. Don't question the constants.
// source: ./src/hexio/HexLogger.java
/// The version of this encoder compatible with .hpyhex binary format
const VERSION: &str = "0.1.0";
/// The version bytes for the current encoder, parsed from the VERSION string
const VERSION_BYTES: [u8; 4] = parse_version(VERSION).to_be_bytes();
/// Magic header for .hpyhex binary files, used to identify and validate the file format
const HEADER_MAGIC: [u8; 16] = 0x4B874B1E5A0F5A0F5A964B874B5A5A87u128.to_be_bytes();
/// Magic header for the data section of .hpyhex binary files, used to identify the start of the data block
const DATA_MAGIC: [u8; 8]    = str_to_bytes("!HEX-BIN");
/// Magic header indicate that these binary files are generated by this Rust encoder
/// 
/// The java version uses "JAVAHXLG"
const VERSION_MAGIC: [u8; 8] = str_to_bytes("hpyhexRS");
/// Bit shift values used for the hashing obfuscation process
const OBFUSC_SHIFTS: [u8; 8] = [31, 37, 41, 27, 23, 29, 33, 43];
/// A large prime number used in the hash function for mixing bits
const OBFUSC_PRIMT:  u64     = 0xC96C5795D7870F3Du64;

/// Obfuscates a long integer using bit shifts and prime multiplications.
/// This function provides a layered transformation for security purposes.
/// 
/// This is used for validating the integrity of the binary file and preventing tampering,
/// as well as for generating unique identifiers for game states.
/// 
/// ## Parameters
/// - `input`: The 64-bit unsigned integer to obfuscate.
/// 
/// ## Returns
/// A new 64-bit unsigned integer that is the obfuscated version of the input.
pub const fn obfuscate(mut input: u64) -> u64 {
    input ^= (input << OBFUSC_SHIFTS[0]) | (input >> OBFUSC_SHIFTS[1]);
    input = input.wrapping_mul(OBFUSC_PRIMT);
    input ^= (input << OBFUSC_SHIFTS[2]) | (input >> OBFUSC_SHIFTS[3]);
    input = input.wrapping_mul(OBFUSC_PRIMT);
    input ^= (input << OBFUSC_SHIFTS[4]) | (input >> OBFUSC_SHIFTS[5]);
    input = input.wrapping_mul(OBFUSC_PRIMT);
    input ^= (input << OBFUSC_SHIFTS[6]) | (input >> OBFUSC_SHIFTS[7]);
    input
}

/// Interleaves the bits of two 32-bit integers into a single 64-bit long.
/// It is superior to just combining two integers together.
///
/// The first integer contributes its bits to the even-numbered bit positions
/// (0, 2, 4, ...) of the result, while the second integer contributes its bits
/// to the odd-numbered bit positions (1, 3, 5, ...).
/// 
/// ## Inputs
/// - `even`: The 32-bit unsigned integer whose bits will occupy the even positions in the output.
/// - `odd`: The 32-bit unsigned integer whose bits will occupy the odd positions in the output.
/// 
/// ## Output
/// A 64-bit unsigned integer where the bits of `even` and `odd` are interleaved.
/// For example, if `even` is `0b1010` and `odd` is `0b0101`, the output will be `0b10011001`.
pub const fn interleave_integers(even: u32, odd: u32) -> u64 {
    let mut e_l = even as u64;
    let mut o_l = odd as u64;

    e_l = (e_l | (e_l << 16)) & 0x0000_FFFF_0000_FFFF;
    o_l = (o_l | (o_l << 16)) & 0x0000_FFFF_0000_FFFF;

    e_l = (e_l | (e_l << 8)) & 0x00FF_00FF_00FF_00FF;
    o_l = (o_l | (o_l << 8)) & 0x00FF_00FF_00FF_00FF;

    e_l = (e_l | (e_l << 4)) & 0x0F0F_0F0F_0F0F_0F0F;
    o_l = (o_l | (o_l << 4)) & 0x0F0F_0F0F_0F0F_0F0F;

    e_l = (e_l | (e_l << 2)) & 0x3333_3333_3333_3333;
    o_l = (o_l | (o_l << 2)) & 0x3333_3333_3333_3333;

    e_l = (e_l | (e_l << 1)) & 0x5555_5555_5555_5555;
    o_l = (o_l | (o_l << 1)) & 0x5555_5555_5555_5555;

    e_l ^ (o_l << 1)
}

/// Converts a string to a fixed-size byte array, padding with zeros if necessary.
/// 
/// ## Parameters
/// - `s`: The input string to convert.
/// - `N`: The size of the output byte array.
/// 
/// ## Returns
/// A byte array of size `N` containing the bytes of the input string,
/// padded with zeros if the string is shorter than `N`.
const fn str_to_bytes<const N: usize>(s: &str) -> [u8; N] {
    let bytes = s.as_bytes();
    let mut arr = [0u8; N];
    let mut i = 0;
    while i < bytes.len() && i < N {
        arr[i] = bytes[i];
        i += 1;
    }
    arr
}

/// Packs a semantic version (major.minor.patch) into a u32
/// Format: [major][minor][patch][0xFF] (big endian)
const fn version_bytes(major: u8, minor: u8, patch: u8) -> u32 {
    ((major as u32) << 24)
        | ((minor as u32) << 16)
        | ((patch as u32) << 8)
        | 0xFF
}

/// Parses a version string in the format "major.minor.patch" into a u32 using `version_bytes`.
const fn parse_version(s: &str) -> u32 {
    let bytes = s.as_bytes();
    let mut i = 0;

    let mut parts = [0u8; 3];
    let mut part = 0u8;
    let mut part_idx = 0;

    while i < bytes.len() {
        let b = bytes[i];
        if b == b'.' {
            parts[part_idx] = part;
            part_idx += 1;
            part = 0;
        } else {
            part = part * 10 + (b - b'0');
        }
        i += 1;
    }
    parts[part_idx] = part;

    version_bytes(parts[0], parts[1], parts[2])
}